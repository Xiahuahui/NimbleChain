// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tendermint/consensus/pcc.proto

package consensus

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type InitRequest struct {
	MI             int64   `protobuf:"varint,1,opt,name=m_i,json=mI,proto3" json:"m_i,omitempty"`
	SMI            int64   `protobuf:"varint,2,opt,name=s_m_i,json=sMI,proto3" json:"s_m_i,omitempty"`
	EpochSize      int64   `protobuf:"varint,3,opt,name=epoch_size,json=epochSize,proto3" json:"epoch_size,omitempty"`
	InitTimeout    int64   `protobuf:"varint,4,opt,name=init_timeout,json=initTimeout,proto3" json:"init_timeout,omitempty"`
	IsByz          bool    `protobuf:"varint,5,opt,name=is_byz,json=isByz,proto3" json:"is_byz,omitempty"`
	IsCrash        bool    `protobuf:"varint,8,opt,name=is_crash,json=isCrash,proto3" json:"is_crash,omitempty"`
	ColdStartPhase int64   `protobuf:"varint,6,opt,name=cold_start_phase,json=coldStartPhase,proto3" json:"cold_start_phase,omitempty"`
	DelayTime      float64 `protobuf:"fixed64,9,opt,name=delay_time,json=delayTime,proto3" json:"delay_time,omitempty"`
	Version        string  `protobuf:"bytes,7,opt,name=version,proto3" json:"version,omitempty"`
	Method         string  `protobuf:"bytes,10,opt,name=method,proto3" json:"method,omitempty"`
	ParaA          float64 `protobuf:"fixed64,11,opt,name=para_a,json=paraA,proto3" json:"para_a,omitempty"`
}

func (m *InitRequest) Reset()         { *m = InitRequest{} }
func (m *InitRequest) String() string { return proto.CompactTextString(m) }
func (*InitRequest) ProtoMessage()    {}
func (*InitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f2ca5fbd1af1e84, []int{0}
}
func (m *InitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitRequest.Merge(m, src)
}
func (m *InitRequest) XXX_Size() int {
	return m.Size()
}
func (m *InitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InitRequest proto.InternalMessageInfo

func (m *InitRequest) GetMI() int64 {
	if m != nil {
		return m.MI
	}
	return 0
}

func (m *InitRequest) GetSMI() int64 {
	if m != nil {
		return m.SMI
	}
	return 0
}

func (m *InitRequest) GetEpochSize() int64 {
	if m != nil {
		return m.EpochSize
	}
	return 0
}

func (m *InitRequest) GetInitTimeout() int64 {
	if m != nil {
		return m.InitTimeout
	}
	return 0
}

func (m *InitRequest) GetIsByz() bool {
	if m != nil {
		return m.IsByz
	}
	return false
}

func (m *InitRequest) GetIsCrash() bool {
	if m != nil {
		return m.IsCrash
	}
	return false
}

func (m *InitRequest) GetColdStartPhase() int64 {
	if m != nil {
		return m.ColdStartPhase
	}
	return 0
}

func (m *InitRequest) GetDelayTime() float64 {
	if m != nil {
		return m.DelayTime
	}
	return 0
}

func (m *InitRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *InitRequest) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *InitRequest) GetParaA() float64 {
	if m != nil {
		return m.ParaA
	}
	return 0
}

type InitResponse struct {
	MI            int64   `protobuf:"varint,1,opt,name=m_i,json=mI,proto3" json:"m_i,omitempty"`
	MiOfNumber    int64   `protobuf:"varint,2,opt,name=mi_of_number,json=miOfNumber,proto3" json:"mi_of_number,omitempty"`
	EpochSizeList []int64 `protobuf:"varint,3,rep,packed,name=epoch_size_list,json=epochSizeList,proto3" json:"epoch_size_list,omitempty"`
	InitTimeout   int64   `protobuf:"varint,4,opt,name=init_timeout,json=initTimeout,proto3" json:"init_timeout,omitempty"`
	DelayTime     float64 `protobuf:"fixed64,5,opt,name=delay_time,json=delayTime,proto3" json:"delay_time,omitempty"`
}

func (m *InitResponse) Reset()         { *m = InitResponse{} }
func (m *InitResponse) String() string { return proto.CompactTextString(m) }
func (*InitResponse) ProtoMessage()    {}
func (*InitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f2ca5fbd1af1e84, []int{1}
}
func (m *InitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitResponse.Merge(m, src)
}
func (m *InitResponse) XXX_Size() int {
	return m.Size()
}
func (m *InitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InitResponse proto.InternalMessageInfo

func (m *InitResponse) GetMI() int64 {
	if m != nil {
		return m.MI
	}
	return 0
}

func (m *InitResponse) GetMiOfNumber() int64 {
	if m != nil {
		return m.MiOfNumber
	}
	return 0
}

func (m *InitResponse) GetEpochSizeList() []int64 {
	if m != nil {
		return m.EpochSizeList
	}
	return nil
}

func (m *InitResponse) GetInitTimeout() int64 {
	if m != nil {
		return m.InitTimeout
	}
	return 0
}

func (m *InitResponse) GetDelayTime() float64 {
	if m != nil {
		return m.DelayTime
	}
	return 0
}

type Cost struct {
	ViewChangeCost int64 `protobuf:"varint,1,opt,name=view_change_cost,json=viewChangeCost,proto3" json:"view_change_cost,omitempty"`
	ThreatCost     int64 `protobuf:"varint,2,opt,name=threat_cost,json=threatCost,proto3" json:"threat_cost,omitempty"`
	Discretionary  int64 `protobuf:"varint,3,opt,name=discretionary,proto3" json:"discretionary,omitempty"`
	Flag           bool  `protobuf:"varint,4,opt,name=flag,proto3" json:"flag,omitempty"`
}

func (m *Cost) Reset()         { *m = Cost{} }
func (m *Cost) String() string { return proto.CompactTextString(m) }
func (*Cost) ProtoMessage()    {}
func (*Cost) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f2ca5fbd1af1e84, []int{2}
}
func (m *Cost) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cost.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cost.Merge(m, src)
}
func (m *Cost) XXX_Size() int {
	return m.Size()
}
func (m *Cost) XXX_DiscardUnknown() {
	xxx_messageInfo_Cost.DiscardUnknown(m)
}

var xxx_messageInfo_Cost proto.InternalMessageInfo

func (m *Cost) GetViewChangeCost() int64 {
	if m != nil {
		return m.ViewChangeCost
	}
	return 0
}

func (m *Cost) GetThreatCost() int64 {
	if m != nil {
		return m.ThreatCost
	}
	return 0
}

func (m *Cost) GetDiscretionary() int64 {
	if m != nil {
		return m.Discretionary
	}
	return 0
}

func (m *Cost) GetFlag() bool {
	if m != nil {
		return m.Flag
	}
	return false
}

type MIData struct {
	Height             []int64   `protobuf:"varint,1,rep,packed,name=height,proto3" json:"height,omitempty"`
	IsLeader           []bool    `protobuf:"varint,2,rep,packed,name=is_leader,json=isLeader,proto3" json:"is_leader,omitempty"`
	ProposerList       []int64   `protobuf:"varint,3,rep,packed,name=proposer_list,json=proposerList,proto3" json:"proposer_list,omitempty"`
	IsByzNode          []bool    `protobuf:"varint,4,rep,packed,name=is_byz_node,json=isByzNode,proto3" json:"is_byz_node,omitempty"`
	ActaulTimeoutList  []float64 `protobuf:"fixed64,5,rep,packed,name=actaul_timeout_list,json=actaulTimeoutList,proto3" json:"actaul_timeout_list,omitempty"`
	PredictTimeoutList []float64 `protobuf:"fixed64,6,rep,packed,name=predict_timeout_list,json=predictTimeoutList,proto3" json:"predict_timeout_list,omitempty"`
	ByzTimeoutList     []float64 `protobuf:"fixed64,7,rep,packed,name=byz_timeout_list,json=byzTimeoutList,proto3" json:"byz_timeout_list,omitempty"`
	Round              []int64   `protobuf:"varint,8,rep,packed,name=round,proto3" json:"round,omitempty"`
	CostList           []*Cost   `protobuf:"bytes,9,rep,name=cost_list,json=costList,proto3" json:"cost_list,omitempty"`
	TimeoutValue       int64     `protobuf:"varint,10,opt,name=timeout_value,json=timeoutValue,proto3" json:"timeout_value,omitempty"`
	LatencyList        []float64 `protobuf:"fixed64,11,rep,packed,name=latency_list,json=latencyList,proto3" json:"latency_list,omitempty"`
	TxNumList          []int64   `protobuf:"varint,12,rep,packed,name=tx_num_list,json=txNumList,proto3" json:"tx_num_list,omitempty"`
	Tps                float64   `protobuf:"fixed64,13,opt,name=tps,proto3" json:"tps,omitempty"`
}

func (m *MIData) Reset()         { *m = MIData{} }
func (m *MIData) String() string { return proto.CompactTextString(m) }
func (*MIData) ProtoMessage()    {}
func (*MIData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f2ca5fbd1af1e84, []int{3}
}
func (m *MIData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MIData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MIData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MIData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MIData.Merge(m, src)
}
func (m *MIData) XXX_Size() int {
	return m.Size()
}
func (m *MIData) XXX_DiscardUnknown() {
	xxx_messageInfo_MIData.DiscardUnknown(m)
}

var xxx_messageInfo_MIData proto.InternalMessageInfo

func (m *MIData) GetHeight() []int64 {
	if m != nil {
		return m.Height
	}
	return nil
}

func (m *MIData) GetIsLeader() []bool {
	if m != nil {
		return m.IsLeader
	}
	return nil
}

func (m *MIData) GetProposerList() []int64 {
	if m != nil {
		return m.ProposerList
	}
	return nil
}

func (m *MIData) GetIsByzNode() []bool {
	if m != nil {
		return m.IsByzNode
	}
	return nil
}

func (m *MIData) GetActaulTimeoutList() []float64 {
	if m != nil {
		return m.ActaulTimeoutList
	}
	return nil
}

func (m *MIData) GetPredictTimeoutList() []float64 {
	if m != nil {
		return m.PredictTimeoutList
	}
	return nil
}

func (m *MIData) GetByzTimeoutList() []float64 {
	if m != nil {
		return m.ByzTimeoutList
	}
	return nil
}

func (m *MIData) GetRound() []int64 {
	if m != nil {
		return m.Round
	}
	return nil
}

func (m *MIData) GetCostList() []*Cost {
	if m != nil {
		return m.CostList
	}
	return nil
}

func (m *MIData) GetTimeoutValue() int64 {
	if m != nil {
		return m.TimeoutValue
	}
	return 0
}

func (m *MIData) GetLatencyList() []float64 {
	if m != nil {
		return m.LatencyList
	}
	return nil
}

func (m *MIData) GetTxNumList() []int64 {
	if m != nil {
		return m.TxNumList
	}
	return nil
}

func (m *MIData) GetTps() float64 {
	if m != nil {
		return m.Tps
	}
	return 0
}

type HeightData struct {
	Height         int64   `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	IsLeader       bool    `protobuf:"varint,2,opt,name=is_leader,json=isLeader,proto3" json:"is_leader,omitempty"`
	Proposer       int64   `protobuf:"varint,3,opt,name=proposer,proto3" json:"proposer,omitempty"`
	IsByzNode      bool    `protobuf:"varint,4,opt,name=is_byz_node,json=isByzNode,proto3" json:"is_byz_node,omitempty"`
	IsCrashNode    bool    `protobuf:"varint,16,opt,name=is_crash_node,json=isCrashNode,proto3" json:"is_crash_node,omitempty"`
	ActaulTimeout  float64 `protobuf:"fixed64,5,opt,name=actaul_timeout,json=actaulTimeout,proto3" json:"actaul_timeout,omitempty"`
	PredictTimeout float64 `protobuf:"fixed64,6,opt,name=predict_timeout,json=predictTimeout,proto3" json:"predict_timeout,omitempty"`
	ByzTimeout     float64 `protobuf:"fixed64,7,opt,name=byz_timeout,json=byzTimeout,proto3" json:"byz_timeout,omitempty"`
	Round          int64   `protobuf:"varint,8,opt,name=round,proto3" json:"round,omitempty"`
	Cost           *Cost   `protobuf:"bytes,9,opt,name=cost,proto3" json:"cost,omitempty"`
	TimeoutValue   int64   `protobuf:"varint,10,opt,name=timeout_value,json=timeoutValue,proto3" json:"timeout_value,omitempty"`
	Latency        float64 `protobuf:"fixed64,11,opt,name=latency,proto3" json:"latency,omitempty"`
	TxNum          int64   `protobuf:"varint,12,opt,name=tx_num,json=txNum,proto3" json:"tx_num,omitempty"`
	Tps            float64 `protobuf:"fixed64,13,opt,name=tps,proto3" json:"tps,omitempty"`
	DelayTime      float64 `protobuf:"fixed64,14,opt,name=delay_time,json=delayTime,proto3" json:"delay_time,omitempty"`
	Pdt            float64 `protobuf:"fixed64,15,opt,name=pdt,proto3" json:"pdt,omitempty"`
	Min            float64 `protobuf:"fixed64,20,opt,name=min,proto3" json:"min,omitempty"`
	Max            float64 `protobuf:"fixed64,17,opt,name=max,proto3" json:"max,omitempty"`
	Avg            float64 `protobuf:"fixed64,18,opt,name=avg,proto3" json:"avg,omitempty"`
	Std            float64 `protobuf:"fixed64,19,opt,name=std,proto3" json:"std,omitempty"`
	DeliverTime    float64 `protobuf:"fixed64,21,opt,name=deliver_time,json=deliverTime,proto3" json:"deliver_time,omitempty"`
}

func (m *HeightData) Reset()         { *m = HeightData{} }
func (m *HeightData) String() string { return proto.CompactTextString(m) }
func (*HeightData) ProtoMessage()    {}
func (*HeightData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f2ca5fbd1af1e84, []int{4}
}
func (m *HeightData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeightData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeightData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeightData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeightData.Merge(m, src)
}
func (m *HeightData) XXX_Size() int {
	return m.Size()
}
func (m *HeightData) XXX_DiscardUnknown() {
	xxx_messageInfo_HeightData.DiscardUnknown(m)
}

var xxx_messageInfo_HeightData proto.InternalMessageInfo

func (m *HeightData) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *HeightData) GetIsLeader() bool {
	if m != nil {
		return m.IsLeader
	}
	return false
}

func (m *HeightData) GetProposer() int64 {
	if m != nil {
		return m.Proposer
	}
	return 0
}

func (m *HeightData) GetIsByzNode() bool {
	if m != nil {
		return m.IsByzNode
	}
	return false
}

func (m *HeightData) GetIsCrashNode() bool {
	if m != nil {
		return m.IsCrashNode
	}
	return false
}

func (m *HeightData) GetActaulTimeout() float64 {
	if m != nil {
		return m.ActaulTimeout
	}
	return 0
}

func (m *HeightData) GetPredictTimeout() float64 {
	if m != nil {
		return m.PredictTimeout
	}
	return 0
}

func (m *HeightData) GetByzTimeout() float64 {
	if m != nil {
		return m.ByzTimeout
	}
	return 0
}

func (m *HeightData) GetRound() int64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *HeightData) GetCost() *Cost {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *HeightData) GetTimeoutValue() int64 {
	if m != nil {
		return m.TimeoutValue
	}
	return 0
}

func (m *HeightData) GetLatency() float64 {
	if m != nil {
		return m.Latency
	}
	return 0
}

func (m *HeightData) GetTxNum() int64 {
	if m != nil {
		return m.TxNum
	}
	return 0
}

func (m *HeightData) GetTps() float64 {
	if m != nil {
		return m.Tps
	}
	return 0
}

func (m *HeightData) GetDelayTime() float64 {
	if m != nil {
		return m.DelayTime
	}
	return 0
}

func (m *HeightData) GetPdt() float64 {
	if m != nil {
		return m.Pdt
	}
	return 0
}

func (m *HeightData) GetMin() float64 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *HeightData) GetMax() float64 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *HeightData) GetAvg() float64 {
	if m != nil {
		return m.Avg
	}
	return 0
}

func (m *HeightData) GetStd() float64 {
	if m != nil {
		return m.Std
	}
	return 0
}

func (m *HeightData) GetDeliverTime() float64 {
	if m != nil {
		return m.DeliverTime
	}
	return 0
}

// 下面这连个需求，
type RunRequest struct {
	MIData []*MIData `protobuf:"bytes,1,rep,name=m_i_data,json=mIData,proto3" json:"m_i_data,omitempty"`
}

func (m *RunRequest) Reset()         { *m = RunRequest{} }
func (m *RunRequest) String() string { return proto.CompactTextString(m) }
func (*RunRequest) ProtoMessage()    {}
func (*RunRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f2ca5fbd1af1e84, []int{5}
}
func (m *RunRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunRequest.Merge(m, src)
}
func (m *RunRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunRequest proto.InternalMessageInfo

func (m *RunRequest) GetMIData() []*MIData {
	if m != nil {
		return m.MIData
	}
	return nil
}

type RunResponse struct {
	MI            int64   `protobuf:"varint,1,opt,name=m_i,json=mI,proto3" json:"m_i,omitempty"`
	MiOfNumber    int64   `protobuf:"varint,2,opt,name=mi_of_number,json=miOfNumber,proto3" json:"mi_of_number,omitempty"`
	EpochSizeList []int64 `protobuf:"varint,3,rep,packed,name=epoch_size_list,json=epochSizeList,proto3" json:"epoch_size_list,omitempty"`
	InitTimeout   int64   `protobuf:"varint,4,opt,name=init_timeout,json=initTimeout,proto3" json:"init_timeout,omitempty"`
}

func (m *RunResponse) Reset()         { *m = RunResponse{} }
func (m *RunResponse) String() string { return proto.CompactTextString(m) }
func (*RunResponse) ProtoMessage()    {}
func (*RunResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f2ca5fbd1af1e84, []int{6}
}
func (m *RunResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunResponse.Merge(m, src)
}
func (m *RunResponse) XXX_Size() int {
	return m.Size()
}
func (m *RunResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RunResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RunResponse proto.InternalMessageInfo

func (m *RunResponse) GetMI() int64 {
	if m != nil {
		return m.MI
	}
	return 0
}

func (m *RunResponse) GetMiOfNumber() int64 {
	if m != nil {
		return m.MiOfNumber
	}
	return 0
}

func (m *RunResponse) GetEpochSizeList() []int64 {
	if m != nil {
		return m.EpochSizeList
	}
	return nil
}

func (m *RunResponse) GetInitTimeout() int64 {
	if m != nil {
		return m.InitTimeout
	}
	return 0
}

// 这个需求应该和MI的一样的。
type RunSpcRequest struct {
	MIData *MIData `protobuf:"bytes,1,opt,name=m_i_data,json=mIData,proto3" json:"m_i_data,omitempty"`
}

func (m *RunSpcRequest) Reset()         { *m = RunSpcRequest{} }
func (m *RunSpcRequest) String() string { return proto.CompactTextString(m) }
func (*RunSpcRequest) ProtoMessage()    {}
func (*RunSpcRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f2ca5fbd1af1e84, []int{7}
}
func (m *RunSpcRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunSpcRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunSpcRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunSpcRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunSpcRequest.Merge(m, src)
}
func (m *RunSpcRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunSpcRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunSpcRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunSpcRequest proto.InternalMessageInfo

func (m *RunSpcRequest) GetMIData() *MIData {
	if m != nil {
		return m.MIData
	}
	return nil
}

// 返回的具体是怎么变 0，1，2，3
type RunSpcResponse struct {
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *RunSpcResponse) Reset()         { *m = RunSpcResponse{} }
func (m *RunSpcResponse) String() string { return proto.CompactTextString(m) }
func (*RunSpcResponse) ProtoMessage()    {}
func (*RunSpcResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f2ca5fbd1af1e84, []int{8}
}
func (m *RunSpcResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunSpcResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunSpcResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunSpcResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunSpcResponse.Merge(m, src)
}
func (m *RunSpcResponse) XXX_Size() int {
	return m.Size()
}
func (m *RunSpcResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RunSpcResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RunSpcResponse proto.InternalMessageInfo

func (m *RunSpcResponse) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

type RunRLJRequest struct {
	HeightData *HeightData `protobuf:"bytes,1,opt,name=height_data,json=heightData,proto3" json:"height_data,omitempty"`
}

func (m *RunRLJRequest) Reset()         { *m = RunRLJRequest{} }
func (m *RunRLJRequest) String() string { return proto.CompactTextString(m) }
func (*RunRLJRequest) ProtoMessage()    {}
func (*RunRLJRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f2ca5fbd1af1e84, []int{9}
}
func (m *RunRLJRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunRLJRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunRLJRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunRLJRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunRLJRequest.Merge(m, src)
}
func (m *RunRLJRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunRLJRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunRLJRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunRLJRequest proto.InternalMessageInfo

func (m *RunRLJRequest) GetHeightData() *HeightData {
	if m != nil {
		return m.HeightData
	}
	return nil
}

type RunRLJResponse struct {
	Code       int64   `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Timeout    float64 `protobuf:"fixed64,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
	ByzTimeout float64 `protobuf:"fixed64,3,opt,name=byz_timeout,json=byzTimeout,proto3" json:"byz_timeout,omitempty"`
	DelayTime  float64 `protobuf:"fixed64,4,opt,name=delay_time,json=delayTime,proto3" json:"delay_time,omitempty"`
}

func (m *RunRLJResponse) Reset()         { *m = RunRLJResponse{} }
func (m *RunRLJResponse) String() string { return proto.CompactTextString(m) }
func (*RunRLJResponse) ProtoMessage()    {}
func (*RunRLJResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f2ca5fbd1af1e84, []int{10}
}
func (m *RunRLJResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunRLJResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunRLJResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunRLJResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunRLJResponse.Merge(m, src)
}
func (m *RunRLJResponse) XXX_Size() int {
	return m.Size()
}
func (m *RunRLJResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RunRLJResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RunRLJResponse proto.InternalMessageInfo

func (m *RunRLJResponse) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RunRLJResponse) GetTimeout() float64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *RunRLJResponse) GetByzTimeout() float64 {
	if m != nil {
		return m.ByzTimeout
	}
	return 0
}

func (m *RunRLJResponse) GetDelayTime() float64 {
	if m != nil {
		return m.DelayTime
	}
	return 0
}

func init() {
	proto.RegisterType((*InitRequest)(nil), "InitRequest")
	proto.RegisterType((*InitResponse)(nil), "InitResponse")
	proto.RegisterType((*Cost)(nil), "Cost")
	proto.RegisterType((*MIData)(nil), "MIData")
	proto.RegisterType((*HeightData)(nil), "HeightData")
	proto.RegisterType((*RunRequest)(nil), "RunRequest")
	proto.RegisterType((*RunResponse)(nil), "RunResponse")
	proto.RegisterType((*RunSpcRequest)(nil), "RunSpcRequest")
	proto.RegisterType((*RunSpcResponse)(nil), "RunSpcResponse")
	proto.RegisterType((*RunRLJRequest)(nil), "RunRLJRequest")
	proto.RegisterType((*RunRLJResponse)(nil), "RunRLJResponse")
}

func init() { proto.RegisterFile("tendermint/consensus/pcc.proto", fileDescriptor_7f2ca5fbd1af1e84) }

var fileDescriptor_7f2ca5fbd1af1e84 = []byte{
	// 1088 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xcf, 0x72, 0xe3, 0xc4,
	0x13, 0xb6, 0x22, 0xff, 0x6d, 0xd9, 0x4e, 0x76, 0x76, 0xf7, 0x57, 0xb3, 0xf9, 0x15, 0xc6, 0xab,
	0xdd, 0x05, 0x57, 0x41, 0x29, 0x54, 0x38, 0x52, 0x1c, 0xd8, 0x70, 0x20, 0x5b, 0xd9, 0x90, 0x52,
	0x80, 0x03, 0x17, 0xd5, 0x44, 0x9a, 0xd8, 0x53, 0x65, 0xfd, 0x41, 0x33, 0x32, 0x71, 0x0e, 0xbc,
	0x00, 0x17, 0xde, 0x83, 0x07, 0x80, 0x33, 0x17, 0x38, 0xee, 0x91, 0x23, 0x95, 0xbc, 0x08, 0x35,
	0x3d, 0x52, 0x2c, 0x25, 0xd9, 0xaa, 0x3d, 0x72, 0xf2, 0xf4, 0x37, 0xdd, 0x3d, 0xd3, 0xdf, 0xd7,
	0xd3, 0x16, 0x4c, 0x14, 0x4f, 0x22, 0x9e, 0xc7, 0x22, 0x51, 0x7b, 0x61, 0x9a, 0x48, 0x9e, 0xc8,
	0x42, 0xee, 0x65, 0x61, 0xe8, 0x65, 0x79, 0xaa, 0x52, 0xf7, 0xf7, 0x2d, 0x70, 0x0e, 0x13, 0xa1,
	0x7c, 0xfe, 0x43, 0xc1, 0xa5, 0x22, 0xdb, 0x60, 0xc7, 0x81, 0xa0, 0xd6, 0xd4, 0x9a, 0xd9, 0xfe,
	0x56, 0x7c, 0x48, 0x08, 0x74, 0x64, 0xa0, 0xa1, 0x2d, 0x84, 0x6c, 0xf9, 0xfa, 0x90, 0xbc, 0x07,
	0xc0, 0xb3, 0x34, 0x5c, 0x04, 0x52, 0x5c, 0x72, 0x6a, 0xe3, 0xc6, 0x00, 0x91, 0x53, 0x71, 0xc9,
	0xc9, 0x53, 0x18, 0x8a, 0x44, 0xa8, 0x40, 0x89, 0x98, 0xa7, 0x85, 0xa2, 0x6d, 0x74, 0x70, 0x34,
	0xf6, 0x8d, 0x81, 0xc8, 0x63, 0xe8, 0x0a, 0x19, 0x9c, 0xad, 0x2f, 0x69, 0x67, 0x6a, 0xcd, 0xfa,
	0x7e, 0x47, 0xc8, 0x97, 0xeb, 0x4b, 0xf2, 0x04, 0xfa, 0x42, 0x06, 0x61, 0xce, 0xe4, 0x82, 0xf6,
	0x71, 0xa3, 0x27, 0xe4, 0x81, 0x36, 0xc9, 0x0c, 0x76, 0xc2, 0x74, 0x19, 0x05, 0x52, 0xb1, 0x5c,
	0x05, 0xd9, 0x82, 0x49, 0x4e, 0xbb, 0x98, 0x78, 0xac, 0xf1, 0x53, 0x0d, 0x9f, 0x68, 0x54, 0xdf,
	0x2e, 0xe2, 0x4b, 0xb6, 0xc6, 0xf3, 0xe9, 0x60, 0x6a, 0xcd, 0x2c, 0x7f, 0x80, 0x88, 0x3e, 0x9d,
	0x50, 0xe8, 0xad, 0x78, 0x2e, 0x45, 0x9a, 0xd0, 0xde, 0xd4, 0x9a, 0x0d, 0xfc, 0xca, 0x24, 0xff,
	0x83, 0x6e, 0xcc, 0xd5, 0x22, 0x8d, 0x28, 0xe0, 0x46, 0x69, 0xe9, 0xcb, 0x66, 0x2c, 0x67, 0x01,
	0xa3, 0x0e, 0x26, 0xeb, 0x68, 0xeb, 0x0b, 0xf7, 0x57, 0x0b, 0x86, 0x86, 0x3a, 0x99, 0x69, 0x66,
	0xef, 0x72, 0x37, 0x85, 0x61, 0x2c, 0x82, 0xf4, 0x3c, 0x48, 0x8a, 0xf8, 0x8c, 0xe7, 0x25, 0x85,
	0x10, 0x8b, 0xaf, 0xcf, 0x8f, 0x11, 0x21, 0x1f, 0xc0, 0xf6, 0x86, 0xc9, 0x60, 0x29, 0xa4, 0xa2,
	0xf6, 0xd4, 0x9e, 0xd9, 0xfe, 0xe8, 0x86, 0xce, 0x23, 0x21, 0xd5, 0xbb, 0x50, 0xda, 0x2c, 0xbb,
	0x73, 0xab, 0x6c, 0xf7, 0x67, 0x0b, 0xda, 0x07, 0xa9, 0x54, 0x9a, 0xc8, 0x95, 0xe0, 0x3f, 0x06,
	0xe1, 0x82, 0x25, 0x73, 0x1e, 0x84, 0xa9, 0x54, 0xe5, 0x95, 0xc7, 0x1a, 0x3f, 0x40, 0x18, 0x3d,
	0xdf, 0x07, 0x47, 0x2d, 0x72, 0xce, 0x94, 0x71, 0x2a, 0x6f, 0x6f, 0x20, 0x74, 0x78, 0x0e, 0xa3,
	0x48, 0xc8, 0x30, 0xe7, 0x4a, 0xa4, 0x09, 0xcb, 0xd7, 0x65, 0x2b, 0x34, 0x41, 0x42, 0xa0, 0x7d,
	0xbe, 0x64, 0x73, 0xbc, 0x73, 0xdf, 0xc7, 0xb5, 0xfb, 0x87, 0x0d, 0xdd, 0xd7, 0x87, 0x5f, 0x32,
	0xc5, 0x34, 0xeb, 0x0b, 0x2e, 0xe6, 0x0b, 0x7d, 0x0b, 0x5d, 0x79, 0x69, 0x91, 0xff, 0xc3, 0x40,
	0xc8, 0x60, 0xc9, 0x59, 0x84, 0xcc, 0xd9, 0xb3, 0xbe, 0xdf, 0x17, 0xf2, 0x08, 0x6d, 0xf2, 0x0c,
	0x46, 0x59, 0x9e, 0x66, 0xa9, 0xe4, 0x79, 0x9d, 0xb5, 0x61, 0x05, 0x22, 0x69, 0x13, 0x70, 0x4c,
	0x93, 0x05, 0x49, 0x1a, 0x71, 0xda, 0xc6, 0x1c, 0x03, 0xec, 0xb4, 0xe3, 0x34, 0xe2, 0xc4, 0x83,
	0x87, 0x2c, 0x54, 0xac, 0x58, 0x56, 0xb4, 0x9a, 0x54, 0x9d, 0xa9, 0x3d, 0xb3, 0xfc, 0x07, 0x66,
	0xab, 0x64, 0x17, 0xf3, 0x7d, 0x02, 0x8f, 0xb2, 0x9c, 0x47, 0x22, 0x54, 0xcd, 0x80, 0x2e, 0x06,
	0x90, 0x72, 0xaf, 0x1e, 0x31, 0x83, 0x1d, 0x7d, 0x7c, 0xc3, 0xbb, 0x87, 0xde, 0xe3, 0xb3, 0xf5,
	0x65, 0xdd, 0xf3, 0x11, 0x74, 0xf2, 0xb4, 0x48, 0x22, 0xda, 0xc7, 0x42, 0x8c, 0x41, 0x5c, 0x18,
	0x68, 0xea, 0x4d, 0xe0, 0x60, 0x6a, 0xcf, 0x9c, 0xfd, 0x8e, 0xa7, 0xa9, 0xf7, 0xfb, 0x1a, 0xc7,
	0xc8, 0x67, 0x30, 0xaa, 0xf2, 0xaf, 0xd8, 0xb2, 0xe0, 0xd8, 0xbc, 0xb6, 0x3f, 0x2c, 0xc1, 0xef,
	0x34, 0xa6, 0xfb, 0x67, 0xc9, 0x14, 0x4f, 0xc2, 0xb5, 0xc9, 0xe5, 0xe0, 0x25, 0x9c, 0x12, 0xab,
	0xd8, 0x52, 0x17, 0xba, 0x53, 0x8d, 0xc7, 0x10, 0xef, 0x31, 0x50, 0x17, 0xc7, 0x45, 0x8c, 0xfb,
	0x3b, 0x60, 0xab, 0x4c, 0xd2, 0x11, 0x36, 0x96, 0x5e, 0xba, 0x7f, 0xb6, 0x01, 0xbe, 0x42, 0xb1,
	0xee, 0x08, 0x69, 0xbd, 0x5d, 0x48, 0xab, 0x21, 0xe4, 0x2e, 0xf4, 0x2b, 0xcd, 0xca, 0xee, 0xb9,
	0xb1, 0xef, 0xea, 0x67, 0x35, 0xf5, 0x73, 0x61, 0x54, 0x4d, 0x0b, 0xe3, 0xb1, 0x83, 0x1e, 0x4e,
	0x39, 0x32, 0xd0, 0xe7, 0x05, 0x8c, 0x9b, 0x1a, 0x97, 0x2f, 0x63, 0xd4, 0x90, 0x97, 0x7c, 0x08,
	0xdb, 0xb7, 0xa4, 0xc5, 0xe1, 0x62, 0xf9, 0xe3, 0xa6, 0xaa, 0xfa, 0x4d, 0xd4, 0x14, 0xc5, 0x09,
	0x62, 0xf9, 0xb0, 0x11, 0xb3, 0x2e, 0xa4, 0xb5, 0x11, 0xf2, 0x09, 0xb4, 0xf1, 0x0d, 0xe9, 0x69,
	0x74, 0xa3, 0x21, 0x42, 0xef, 0xa6, 0x1f, 0x85, 0x5e, 0xa9, 0x55, 0x39, 0x83, 0x2a, 0x53, 0x0f,
	0x27, 0x23, 0x1b, 0x1d, 0x9a, 0x03, 0x51, 0xb1, 0xbb, 0x6a, 0xdd, 0x9a, 0x0f, 0xe3, 0xdb, 0x63,
	0x71, 0x07, 0xec, 0x2c, 0x52, 0x74, 0xdb, 0x04, 0x64, 0x11, 0x0a, 0x1e, 0x8b, 0x84, 0x3e, 0x32,
	0x48, 0x2c, 0x12, 0x44, 0xd8, 0x05, 0x7d, 0x50, 0x22, 0xec, 0x42, 0x23, 0x6c, 0x35, 0xa7, 0xc4,
	0x20, 0x6c, 0x35, 0xd7, 0x88, 0x54, 0x11, 0x7d, 0x68, 0x10, 0xa9, 0x22, 0xdd, 0x7b, 0x11, 0x5f,
	0x8a, 0x15, 0xcf, 0xcd, 0xd1, 0x8f, 0x71, 0xcb, 0x29, 0x31, 0x1c, 0x4e, 0x7b, 0x00, 0x7e, 0x91,
	0x54, 0xff, 0x41, 0x4f, 0xa1, 0x1f, 0x07, 0x22, 0x88, 0x98, 0x62, 0x38, 0x13, 0x9c, 0xfd, 0x9e,
	0x67, 0x86, 0x85, 0xdf, 0x8d, 0xf1, 0x57, 0x4f, 0x33, 0x07, 0x23, 0xfe, 0x0b, 0xa3, 0xd7, 0xdd,
	0x87, 0x91, 0x5f, 0x24, 0xa7, 0x59, 0x78, 0x7f, 0x05, 0xd6, 0x7d, 0x15, 0x3c, 0x87, 0x71, 0x15,
	0x53, 0xd6, 0x40, 0x74, 0x8f, 0x44, 0xbc, 0x2c, 0x02, 0xd7, 0xee, 0xe7, 0x98, 0xd9, 0x3f, 0x7a,
	0x55, 0x65, 0xfe, 0x18, 0x1c, 0xf3, 0xac, 0xea, 0xc9, 0x1d, 0x6f, 0xf3, 0x0c, 0x7d, 0x58, 0xdc,
	0xac, 0xdd, 0x9f, 0xf0, 0x10, 0x0c, 0x7f, 0xfb, 0x21, 0xba, 0xb9, 0xaa, 0xe2, 0xb6, 0x4c, 0x73,
	0xa9, 0xfb, 0xbb, 0xdd, 0xbe, 0xd3, 0xed, 0xcd, 0xa6, 0x6a, 0xdf, 0x6a, 0xaa, 0xfd, 0xdf, 0x2c,
	0x80, 0x93, 0x30, 0x3c, 0xe5, 0xf9, 0x4a, 0x84, 0x9c, 0xcc, 0xa0, 0xa7, 0xff, 0x30, 0x4f, 0x0e,
	0x0e, 0xc8, 0xd0, 0xab, 0x7d, 0x75, 0xec, 0x8e, 0xbc, 0xfa, 0x1f, 0xa9, 0xdb, 0x22, 0x2f, 0xa0,
	0xeb, 0x17, 0xc9, 0x49, 0x18, 0x12, 0xc7, 0xdb, 0x74, 0xc6, 0xee, 0xd0, 0xab, 0x89, 0xee, 0xb6,
	0xc8, 0x47, 0xe8, 0x76, 0x9a, 0x85, 0x64, 0xec, 0x35, 0x14, 0xd8, 0xdd, 0xf6, 0x9a, 0xec, 0xde,
	0x38, 0xfb, 0x47, 0xaf, 0x8c, 0xf3, 0x86, 0x54, 0xe3, 0x5c, 0x63, 0xc9, 0x6d, 0xbd, 0xfc, 0xf6,
	0xaf, 0xab, 0x89, 0xf5, 0xe6, 0x6a, 0x62, 0xfd, 0x73, 0x35, 0xb1, 0x7e, 0xb9, 0x9e, 0xb4, 0xde,
	0x5c, 0x4f, 0x5a, 0x7f, 0x5f, 0x4f, 0x5a, 0xdf, 0x7f, 0x36, 0x17, 0x6a, 0x51, 0x9c, 0x79, 0x61,
	0x1a, 0xef, 0xd5, 0x3e, 0xae, 0x6a, 0x4b, 0xfc, 0xb2, 0xda, 0xbb, 0xef, 0xc3, 0xeb, 0xac, 0x8b,
	0x7b, 0x9f, 0xfe, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x3f, 0x45, 0x42, 0x20, 0x97, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PccServiceClient is the client API for PccService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PccServiceClient interface {
	InitPCC(ctx context.Context, in *InitRequest, opts ...grpc.CallOption) (*InitResponse, error)
	RunPcc(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (*RunResponse, error)
	RunSpc(ctx context.Context, in *RunSpcRequest, opts ...grpc.CallOption) (*RunSpcResponse, error)
	RunRLJ(ctx context.Context, in *RunRLJRequest, opts ...grpc.CallOption) (*RunRLJResponse, error)
}

type pccServiceClient struct {
	cc *grpc.ClientConn
}

func NewPccServiceClient(cc *grpc.ClientConn) PccServiceClient {
	return &pccServiceClient{cc}
}

func (c *pccServiceClient) InitPCC(ctx context.Context, in *InitRequest, opts ...grpc.CallOption) (*InitResponse, error) {
	out := new(InitResponse)
	err := c.cc.Invoke(ctx, "/PccService/InitPCC", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pccServiceClient) RunPcc(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (*RunResponse, error) {
	out := new(RunResponse)
	err := c.cc.Invoke(ctx, "/PccService/RunPcc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pccServiceClient) RunSpc(ctx context.Context, in *RunSpcRequest, opts ...grpc.CallOption) (*RunSpcResponse, error) {
	out := new(RunSpcResponse)
	err := c.cc.Invoke(ctx, "/PccService/RunSpc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pccServiceClient) RunRLJ(ctx context.Context, in *RunRLJRequest, opts ...grpc.CallOption) (*RunRLJResponse, error) {
	out := new(RunRLJResponse)
	err := c.cc.Invoke(ctx, "/PccService/RunRLJ", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PccServiceServer is the server API for PccService service.
type PccServiceServer interface {
	InitPCC(context.Context, *InitRequest) (*InitResponse, error)
	RunPcc(context.Context, *RunRequest) (*RunResponse, error)
	RunSpc(context.Context, *RunSpcRequest) (*RunSpcResponse, error)
	RunRLJ(context.Context, *RunRLJRequest) (*RunRLJResponse, error)
}

// UnimplementedPccServiceServer can be embedded to have forward compatible implementations.
type UnimplementedPccServiceServer struct {
}

func (*UnimplementedPccServiceServer) InitPCC(ctx context.Context, req *InitRequest) (*InitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitPCC not implemented")
}
func (*UnimplementedPccServiceServer) RunPcc(ctx context.Context, req *RunRequest) (*RunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunPcc not implemented")
}
func (*UnimplementedPccServiceServer) RunSpc(ctx context.Context, req *RunSpcRequest) (*RunSpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunSpc not implemented")
}
func (*UnimplementedPccServiceServer) RunRLJ(ctx context.Context, req *RunRLJRequest) (*RunRLJResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunRLJ not implemented")
}

func RegisterPccServiceServer(s *grpc.Server, srv PccServiceServer) {
	s.RegisterService(&_PccService_serviceDesc, srv)
}

func _PccService_InitPCC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PccServiceServer).InitPCC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PccService/InitPCC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PccServiceServer).InitPCC(ctx, req.(*InitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PccService_RunPcc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PccServiceServer).RunPcc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PccService/RunPcc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PccServiceServer).RunPcc(ctx, req.(*RunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PccService_RunSpc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunSpcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PccServiceServer).RunSpc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PccService/RunSpc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PccServiceServer).RunSpc(ctx, req.(*RunSpcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PccService_RunRLJ_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunRLJRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PccServiceServer).RunRLJ(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PccService/RunRLJ",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PccServiceServer).RunRLJ(ctx, req.(*RunRLJRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PccService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "PccService",
	HandlerType: (*PccServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitPCC",
			Handler:    _PccService_InitPCC_Handler,
		},
		{
			MethodName: "RunPcc",
			Handler:    _PccService_RunPcc_Handler,
		},
		{
			MethodName: "RunSpc",
			Handler:    _PccService_RunSpc_Handler,
		},
		{
			MethodName: "RunRLJ",
			Handler:    _PccService_RunRLJ_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tendermint/consensus/pcc.proto",
}

func (m *InitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ParaA != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ParaA))))
		i--
		dAtA[i] = 0x59
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintPcc(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x52
	}
	if m.DelayTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DelayTime))))
		i--
		dAtA[i] = 0x49
	}
	if m.IsCrash {
		i--
		if m.IsCrash {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintPcc(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ColdStartPhase != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.ColdStartPhase))
		i--
		dAtA[i] = 0x30
	}
	if m.IsByz {
		i--
		if m.IsByz {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.InitTimeout != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.InitTimeout))
		i--
		dAtA[i] = 0x20
	}
	if m.EpochSize != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.EpochSize))
		i--
		dAtA[i] = 0x18
	}
	if m.SMI != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.SMI))
		i--
		dAtA[i] = 0x10
	}
	if m.MI != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.MI))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelayTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DelayTime))))
		i--
		dAtA[i] = 0x29
	}
	if m.InitTimeout != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.InitTimeout))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EpochSizeList) > 0 {
		dAtA2 := make([]byte, len(m.EpochSizeList)*10)
		var j1 int
		for _, num1 := range m.EpochSizeList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintPcc(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if m.MiOfNumber != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.MiOfNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.MI != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.MI))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Cost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cost) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cost) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Flag {
		i--
		if m.Flag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Discretionary != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.Discretionary))
		i--
		dAtA[i] = 0x18
	}
	if m.ThreatCost != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.ThreatCost))
		i--
		dAtA[i] = 0x10
	}
	if m.ViewChangeCost != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.ViewChangeCost))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MIData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MIData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MIData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tps != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Tps))))
		i--
		dAtA[i] = 0x69
	}
	if len(m.TxNumList) > 0 {
		dAtA4 := make([]byte, len(m.TxNumList)*10)
		var j3 int
		for _, num1 := range m.TxNumList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintPcc(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x62
	}
	if len(m.LatencyList) > 0 {
		for iNdEx := len(m.LatencyList) - 1; iNdEx >= 0; iNdEx-- {
			f5 := math.Float64bits(float64(m.LatencyList[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f5))
		}
		i = encodeVarintPcc(dAtA, i, uint64(len(m.LatencyList)*8))
		i--
		dAtA[i] = 0x5a
	}
	if m.TimeoutValue != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.TimeoutValue))
		i--
		dAtA[i] = 0x50
	}
	if len(m.CostList) > 0 {
		for iNdEx := len(m.CostList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CostList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPcc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Round) > 0 {
		dAtA7 := make([]byte, len(m.Round)*10)
		var j6 int
		for _, num1 := range m.Round {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintPcc(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ByzTimeoutList) > 0 {
		for iNdEx := len(m.ByzTimeoutList) - 1; iNdEx >= 0; iNdEx-- {
			f8 := math.Float64bits(float64(m.ByzTimeoutList[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f8))
		}
		i = encodeVarintPcc(dAtA, i, uint64(len(m.ByzTimeoutList)*8))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PredictTimeoutList) > 0 {
		for iNdEx := len(m.PredictTimeoutList) - 1; iNdEx >= 0; iNdEx-- {
			f9 := math.Float64bits(float64(m.PredictTimeoutList[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f9))
		}
		i = encodeVarintPcc(dAtA, i, uint64(len(m.PredictTimeoutList)*8))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ActaulTimeoutList) > 0 {
		for iNdEx := len(m.ActaulTimeoutList) - 1; iNdEx >= 0; iNdEx-- {
			f10 := math.Float64bits(float64(m.ActaulTimeoutList[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f10))
		}
		i = encodeVarintPcc(dAtA, i, uint64(len(m.ActaulTimeoutList)*8))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.IsByzNode) > 0 {
		for iNdEx := len(m.IsByzNode) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.IsByzNode[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintPcc(dAtA, i, uint64(len(m.IsByzNode)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ProposerList) > 0 {
		dAtA12 := make([]byte, len(m.ProposerList)*10)
		var j11 int
		for _, num1 := range m.ProposerList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintPcc(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.IsLeader) > 0 {
		for iNdEx := len(m.IsLeader) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.IsLeader[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintPcc(dAtA, i, uint64(len(m.IsLeader)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Height) > 0 {
		dAtA14 := make([]byte, len(m.Height)*10)
		var j13 int
		for _, num1 := range m.Height {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintPcc(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeightData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeightData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeightData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeliverTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DeliverTime))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa9
	}
	if m.Min != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Min))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa1
	}
	if m.Std != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Std))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x99
	}
	if m.Avg != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Avg))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x91
	}
	if m.Max != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Max))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if m.IsCrashNode {
		i--
		if m.IsCrashNode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Pdt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Pdt))))
		i--
		dAtA[i] = 0x79
	}
	if m.DelayTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DelayTime))))
		i--
		dAtA[i] = 0x71
	}
	if m.Tps != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Tps))))
		i--
		dAtA[i] = 0x69
	}
	if m.TxNum != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.TxNum))
		i--
		dAtA[i] = 0x60
	}
	if m.Latency != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latency))))
		i--
		dAtA[i] = 0x59
	}
	if m.TimeoutValue != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.TimeoutValue))
		i--
		dAtA[i] = 0x50
	}
	if m.Cost != nil {
		{
			size, err := m.Cost.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPcc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Round != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x40
	}
	if m.ByzTimeout != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ByzTimeout))))
		i--
		dAtA[i] = 0x39
	}
	if m.PredictTimeout != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PredictTimeout))))
		i--
		dAtA[i] = 0x31
	}
	if m.ActaulTimeout != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ActaulTimeout))))
		i--
		dAtA[i] = 0x29
	}
	if m.IsByzNode {
		i--
		if m.IsByzNode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Proposer != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.Proposer))
		i--
		dAtA[i] = 0x18
	}
	if m.IsLeader {
		i--
		if m.IsLeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RunRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MIData) > 0 {
		for iNdEx := len(m.MIData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MIData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPcc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RunResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InitTimeout != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.InitTimeout))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EpochSizeList) > 0 {
		dAtA17 := make([]byte, len(m.EpochSizeList)*10)
		var j16 int
		for _, num1 := range m.EpochSizeList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintPcc(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0x1a
	}
	if m.MiOfNumber != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.MiOfNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.MI != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.MI))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RunSpcRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunSpcRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunSpcRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MIData != nil {
		{
			size, err := m.MIData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPcc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunSpcResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunSpcResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunSpcResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RunRLJRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunRLJRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunRLJRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HeightData != nil {
		{
			size, err := m.HeightData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPcc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunRLJResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunRLJResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunRLJResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelayTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DelayTime))))
		i--
		dAtA[i] = 0x21
	}
	if m.ByzTimeout != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ByzTimeout))))
		i--
		dAtA[i] = 0x19
	}
	if m.Timeout != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Timeout))))
		i--
		dAtA[i] = 0x11
	}
	if m.Code != 0 {
		i = encodeVarintPcc(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPcc(dAtA []byte, offset int, v uint64) int {
	offset -= sovPcc(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *InitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MI != 0 {
		n += 1 + sovPcc(uint64(m.MI))
	}
	if m.SMI != 0 {
		n += 1 + sovPcc(uint64(m.SMI))
	}
	if m.EpochSize != 0 {
		n += 1 + sovPcc(uint64(m.EpochSize))
	}
	if m.InitTimeout != 0 {
		n += 1 + sovPcc(uint64(m.InitTimeout))
	}
	if m.IsByz {
		n += 2
	}
	if m.ColdStartPhase != 0 {
		n += 1 + sovPcc(uint64(m.ColdStartPhase))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovPcc(uint64(l))
	}
	if m.IsCrash {
		n += 2
	}
	if m.DelayTime != 0 {
		n += 9
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovPcc(uint64(l))
	}
	if m.ParaA != 0 {
		n += 9
	}
	return n
}

func (m *InitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MI != 0 {
		n += 1 + sovPcc(uint64(m.MI))
	}
	if m.MiOfNumber != 0 {
		n += 1 + sovPcc(uint64(m.MiOfNumber))
	}
	if len(m.EpochSizeList) > 0 {
		l = 0
		for _, e := range m.EpochSizeList {
			l += sovPcc(uint64(e))
		}
		n += 1 + sovPcc(uint64(l)) + l
	}
	if m.InitTimeout != 0 {
		n += 1 + sovPcc(uint64(m.InitTimeout))
	}
	if m.DelayTime != 0 {
		n += 9
	}
	return n
}

func (m *Cost) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ViewChangeCost != 0 {
		n += 1 + sovPcc(uint64(m.ViewChangeCost))
	}
	if m.ThreatCost != 0 {
		n += 1 + sovPcc(uint64(m.ThreatCost))
	}
	if m.Discretionary != 0 {
		n += 1 + sovPcc(uint64(m.Discretionary))
	}
	if m.Flag {
		n += 2
	}
	return n
}

func (m *MIData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Height) > 0 {
		l = 0
		for _, e := range m.Height {
			l += sovPcc(uint64(e))
		}
		n += 1 + sovPcc(uint64(l)) + l
	}
	if len(m.IsLeader) > 0 {
		n += 1 + sovPcc(uint64(len(m.IsLeader))) + len(m.IsLeader)*1
	}
	if len(m.ProposerList) > 0 {
		l = 0
		for _, e := range m.ProposerList {
			l += sovPcc(uint64(e))
		}
		n += 1 + sovPcc(uint64(l)) + l
	}
	if len(m.IsByzNode) > 0 {
		n += 1 + sovPcc(uint64(len(m.IsByzNode))) + len(m.IsByzNode)*1
	}
	if len(m.ActaulTimeoutList) > 0 {
		n += 1 + sovPcc(uint64(len(m.ActaulTimeoutList)*8)) + len(m.ActaulTimeoutList)*8
	}
	if len(m.PredictTimeoutList) > 0 {
		n += 1 + sovPcc(uint64(len(m.PredictTimeoutList)*8)) + len(m.PredictTimeoutList)*8
	}
	if len(m.ByzTimeoutList) > 0 {
		n += 1 + sovPcc(uint64(len(m.ByzTimeoutList)*8)) + len(m.ByzTimeoutList)*8
	}
	if len(m.Round) > 0 {
		l = 0
		for _, e := range m.Round {
			l += sovPcc(uint64(e))
		}
		n += 1 + sovPcc(uint64(l)) + l
	}
	if len(m.CostList) > 0 {
		for _, e := range m.CostList {
			l = e.Size()
			n += 1 + l + sovPcc(uint64(l))
		}
	}
	if m.TimeoutValue != 0 {
		n += 1 + sovPcc(uint64(m.TimeoutValue))
	}
	if len(m.LatencyList) > 0 {
		n += 1 + sovPcc(uint64(len(m.LatencyList)*8)) + len(m.LatencyList)*8
	}
	if len(m.TxNumList) > 0 {
		l = 0
		for _, e := range m.TxNumList {
			l += sovPcc(uint64(e))
		}
		n += 1 + sovPcc(uint64(l)) + l
	}
	if m.Tps != 0 {
		n += 9
	}
	return n
}

func (m *HeightData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovPcc(uint64(m.Height))
	}
	if m.IsLeader {
		n += 2
	}
	if m.Proposer != 0 {
		n += 1 + sovPcc(uint64(m.Proposer))
	}
	if m.IsByzNode {
		n += 2
	}
	if m.ActaulTimeout != 0 {
		n += 9
	}
	if m.PredictTimeout != 0 {
		n += 9
	}
	if m.ByzTimeout != 0 {
		n += 9
	}
	if m.Round != 0 {
		n += 1 + sovPcc(uint64(m.Round))
	}
	if m.Cost != nil {
		l = m.Cost.Size()
		n += 1 + l + sovPcc(uint64(l))
	}
	if m.TimeoutValue != 0 {
		n += 1 + sovPcc(uint64(m.TimeoutValue))
	}
	if m.Latency != 0 {
		n += 9
	}
	if m.TxNum != 0 {
		n += 1 + sovPcc(uint64(m.TxNum))
	}
	if m.Tps != 0 {
		n += 9
	}
	if m.DelayTime != 0 {
		n += 9
	}
	if m.Pdt != 0 {
		n += 9
	}
	if m.IsCrashNode {
		n += 3
	}
	if m.Max != 0 {
		n += 10
	}
	if m.Avg != 0 {
		n += 10
	}
	if m.Std != 0 {
		n += 10
	}
	if m.Min != 0 {
		n += 10
	}
	if m.DeliverTime != 0 {
		n += 10
	}
	return n
}

func (m *RunRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MIData) > 0 {
		for _, e := range m.MIData {
			l = e.Size()
			n += 1 + l + sovPcc(uint64(l))
		}
	}
	return n
}

func (m *RunResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MI != 0 {
		n += 1 + sovPcc(uint64(m.MI))
	}
	if m.MiOfNumber != 0 {
		n += 1 + sovPcc(uint64(m.MiOfNumber))
	}
	if len(m.EpochSizeList) > 0 {
		l = 0
		for _, e := range m.EpochSizeList {
			l += sovPcc(uint64(e))
		}
		n += 1 + sovPcc(uint64(l)) + l
	}
	if m.InitTimeout != 0 {
		n += 1 + sovPcc(uint64(m.InitTimeout))
	}
	return n
}

func (m *RunSpcRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MIData != nil {
		l = m.MIData.Size()
		n += 1 + l + sovPcc(uint64(l))
	}
	return n
}

func (m *RunSpcResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPcc(uint64(m.Code))
	}
	return n
}

func (m *RunRLJRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeightData != nil {
		l = m.HeightData.Size()
		n += 1 + l + sovPcc(uint64(l))
	}
	return n
}

func (m *RunRLJResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPcc(uint64(m.Code))
	}
	if m.Timeout != 0 {
		n += 9
	}
	if m.ByzTimeout != 0 {
		n += 9
	}
	if m.DelayTime != 0 {
		n += 9
	}
	return n
}

func sovPcc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPcc(x uint64) (n int) {
	return sovPcc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MI", wireType)
			}
			m.MI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SMI", wireType)
			}
			m.SMI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SMI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochSize", wireType)
			}
			m.EpochSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitTimeout", wireType)
			}
			m.InitTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsByz", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsByz = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColdStartPhase", wireType)
			}
			m.ColdStartPhase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColdStartPhase |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCrash", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCrash = bool(v != 0)
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DelayTime = float64(math.Float64frombits(v))
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParaA", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ParaA = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MI", wireType)
			}
			m.MI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiOfNumber", wireType)
			}
			m.MiOfNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MiOfNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EpochSizeList = append(m.EpochSizeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPcc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPcc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EpochSizeList) == 0 {
					m.EpochSizeList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPcc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EpochSizeList = append(m.EpochSizeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochSizeList", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitTimeout", wireType)
			}
			m.InitTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DelayTime = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewChangeCost", wireType)
			}
			m.ViewChangeCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViewChangeCost |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreatCost", wireType)
			}
			m.ThreatCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThreatCost |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discretionary", wireType)
			}
			m.Discretionary = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Discretionary |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flag = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MIData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MIData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MIData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Height = append(m.Height, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPcc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPcc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Height) == 0 {
					m.Height = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPcc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Height = append(m.Height, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IsLeader = append(m.IsLeader, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPcc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPcc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.IsLeader) == 0 {
					m.IsLeader = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPcc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IsLeader = append(m.IsLeader, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeader", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ProposerList = append(m.ProposerList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPcc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPcc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ProposerList) == 0 {
					m.ProposerList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPcc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ProposerList = append(m.ProposerList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerList", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IsByzNode = append(m.IsByzNode, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPcc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPcc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.IsByzNode) == 0 {
					m.IsByzNode = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPcc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IsByzNode = append(m.IsByzNode, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IsByzNode", wireType)
			}
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.ActaulTimeoutList = append(m.ActaulTimeoutList, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPcc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPcc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.ActaulTimeoutList) == 0 {
					m.ActaulTimeoutList = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.ActaulTimeoutList = append(m.ActaulTimeoutList, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActaulTimeoutList", wireType)
			}
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.PredictTimeoutList = append(m.PredictTimeoutList, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPcc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPcc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.PredictTimeoutList) == 0 {
					m.PredictTimeoutList = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.PredictTimeoutList = append(m.PredictTimeoutList, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictTimeoutList", wireType)
			}
		case 7:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.ByzTimeoutList = append(m.ByzTimeoutList, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPcc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPcc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.ByzTimeoutList) == 0 {
					m.ByzTimeoutList = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.ByzTimeoutList = append(m.ByzTimeoutList, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ByzTimeoutList", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Round = append(m.Round, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPcc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPcc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Round) == 0 {
					m.Round = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPcc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Round = append(m.Round, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPcc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CostList = append(m.CostList, &Cost{})
			if err := m.CostList[len(m.CostList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutValue", wireType)
			}
			m.TimeoutValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.LatencyList = append(m.LatencyList, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPcc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPcc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.LatencyList) == 0 {
					m.LatencyList = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.LatencyList = append(m.LatencyList, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyList", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TxNumList = append(m.TxNumList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPcc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPcc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TxNumList) == 0 {
					m.TxNumList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPcc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TxNumList = append(m.TxNumList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TxNumList", wireType)
			}
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tps", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Tps = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeightData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeightData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeightData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeader = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			m.Proposer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposer |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsByzNode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsByzNode = bool(v != 0)
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActaulTimeout", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ActaulTimeout = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictTimeout", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PredictTimeout = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByzTimeout", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ByzTimeout = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPcc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &Cost{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutValue", wireType)
			}
			m.TimeoutValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latency", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latency = float64(math.Float64frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxNum", wireType)
			}
			m.TxNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tps", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Tps = float64(math.Float64frombits(v))
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DelayTime = float64(math.Float64frombits(v))
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pdt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Pdt = float64(math.Float64frombits(v))
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCrashNode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCrashNode = bool(v != 0)
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Max = float64(math.Float64frombits(v))
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avg", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Avg = float64(math.Float64frombits(v))
		case 19:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Std", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Std = float64(math.Float64frombits(v))
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Min = float64(math.Float64frombits(v))
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliverTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DeliverTime = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MIData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPcc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MIData = append(m.MIData, &MIData{})
			if err := m.MIData[len(m.MIData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MI", wireType)
			}
			m.MI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiOfNumber", wireType)
			}
			m.MiOfNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MiOfNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EpochSizeList = append(m.EpochSizeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPcc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPcc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EpochSizeList) == 0 {
					m.EpochSizeList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPcc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EpochSizeList = append(m.EpochSizeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochSizeList", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitTimeout", wireType)
			}
			m.InitTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunSpcRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunSpcRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunSpcRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MIData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPcc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MIData == nil {
				m.MIData = &MIData{}
			}
			if err := m.MIData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunSpcResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunSpcResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunSpcResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunRLJRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunRLJRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunRLJRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeightData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPcc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeightData == nil {
				m.HeightData = &HeightData{}
			}
			if err := m.HeightData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunRLJResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunRLJResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunRLJResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Timeout = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByzTimeout", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ByzTimeout = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DelayTime = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPcc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPcc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPcc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPcc
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPcc
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPcc
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPcc        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPcc          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPcc = fmt.Errorf("proto: unexpected end of group")
)
